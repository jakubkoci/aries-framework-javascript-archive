import indy from 'indy-sdk';
import logger from './logger';
import { InboundMessage, Message } from './types';
import { sign } from './decorators';

interface Wallet {
  init(): Promise<void>;
  close(): Promise<void>;
  delete(): Promise<void>;
  initPublicDid(did: Did, seed: string): Promise<void>;
  getPublicDid(): DidInfo | {};
  createDid(didConfig?: DidConfig): Promise<[Did, Verkey]>;
  pack(payload: {}, recipientKeys: Verkey[], senderVk: Verkey | null): Promise<JsonWebKey>;
  unpack(messagePackage: JsonWebKey): Promise<InboundMessage>;
  sign(message: Message, attribute: string, verkey: Verkey): Promise<Message>;
  verify(signerVerkey: Verkey, data: Buffer, signature: Buffer): Promise<boolean>;
}

interface DidInfo {
  did: Did;
  verkey: Verkey;
}

interface DidConfig {
  did: string;
  seed: string;
}

interface WalletConfig {
  id: string;
}

interface WalletCredentials {
  key: string;
}

class IndyWallet implements Wallet {
  wh?: number;
  walletConfig: WalletConfig;
  walletCredentials: WalletCredentials;
  publicDid: DidInfo | {} = {};

  constructor(walletConfig: WalletConfig, walletCredentials: WalletCredentials) {
    this.walletConfig = walletConfig;
    this.walletCredentials = walletCredentials;
  }

  async init() {
    try {
      await indy.createWallet(this.walletConfig, this.walletCredentials);
    } catch (error) {
      if (error.indyName && error.indyName === 'WalletAlreadyExistsError') {
        logger.log(error.indyName);
      } else {
        throw error;
      }
    }

    this.wh = await indy.openWallet(this.walletConfig, this.walletCredentials);
    logger.log(`Wallet opened with handle: ${this.wh}`);
  }

  async initPublicDid(did: Did, seed: string) {
    let didInfo = {};
    try {
      const existingVerkey = await this.keyForLocalDid(did);
      // TODO validate that verkey is as same as the verkey generated by given seed
      didInfo = {
        did,
        verkey: existingVerkey,
      };
    } catch (error) {
      if (error.name === 'IndyError' && error.message === '212') {
        // WalletItemNotFound
        logger.log('WalletItemNotFound');
        const [_, verkey] = await this.createDid({ did, seed });
        didInfo = {
          did,
          verkey,
        };
      } else {
        throw error;
      }
    }

    this.publicDid = didInfo;
  }

  getPublicDid(): DidInfo | {} {
    return this.publicDid;
  }

  async createDid(didConfig?: DidConfig): Promise<[Did, Verkey]> {
    if (!this.wh) {
      throw Error('Wallet has not been initialized yet');
    }

    return indy.createAndStoreMyDid(this.wh, didConfig || {});
  }

  async pack(payload: {}, recipientKeys: Verkey[], senderVk: Verkey): Promise<JsonWebKey> {
    if (!this.wh) {
      throw Error('Wallet has not been initialized yet');
    }

    const messageRaw = Buffer.from(JSON.stringify(payload), 'utf-8');
    const packedMessage = await indy.packMessage(this.wh, messageRaw, recipientKeys, senderVk);
    return JSON.parse(packedMessage.toString('utf-8'));
  }

  async unpack(messagePackage: JsonWebKey): Promise<InboundMessage> {
    if (!this.wh) {
      throw Error('Wallet has not been initialized yet');
    }

    const unpackedMessageBuffer = await indy.unpackMessage(
      this.wh,
      Buffer.from(JSON.stringify(messagePackage), 'utf-8')
    );
    const unpackedMessage = JSON.parse(unpackedMessageBuffer.toString('utf-8'));
    return {
      ...unpackedMessage,
      message: JSON.parse(unpackedMessage.message),
    };
  }

  async sign(message: Message, attribute: string, verkey: Verkey) {
    if (!this.wh) {
      throw Error('Wallet has not been initialized yet');
    }

    return sign(this.wh, message, attribute, verkey);
  }

  async verify(signerVerkey: Verkey, data: Buffer, signature: Buffer) {
    return indy.cryptoVerify(signerVerkey, data, signature);
  }

  async close() {
    if (!this.wh) {
      throw Error('Wallet has not been initialized yet');
    }

    return indy.closeWallet(this.wh);
  }

  async delete() {
    if (!this.wh) {
      throw Error('Wallet has not been initialized yet');
    }

    return indy.deleteWallet(this.walletConfig, this.walletCredentials);
  }

  private keyForLocalDid(did: Did) {
    if (!this.wh) {
      throw Error('Wallet has not been initialized yet');
    }

    return indy.keyForLocalDid(this.wh, did);
  }
}

export { Wallet, IndyWallet };
